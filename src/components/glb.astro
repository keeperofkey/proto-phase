---

---
<script>
import * as THREE from 'three';
import frame from '../components/canvas.html'


import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

import type { claim_space } from 'svelte/internal';

let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: { enableDamping: boolean; minDistance: number; maxDistance: number; target: { set: (arg0: number, arg1: number, arg2: number) => void; }; update: () => void; };
let model: THREE.Object3D<THREE.Event>
let anim: THREE.AnimationClip[]
let cams
let mixer: THREE.AnimationMixer
let action: THREE.AnimationAction
let clip
let nextpos
let nextrot
let time: THREE.Clock

let focus = new THREE.Vector3();
let quat = new THREE.Quaternion();
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const Clock = new THREE.Clock();
init();
// animate();

function init() {

    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.zIndex = '-1';
    document.body.appendChild( container );
    

    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 20 );
    camera.position.set( -10, 10, 10 );
    camera.lookAt(focus);

    scene = new THREE.Scene();
    // model

    new GLTFLoader()
        .setPath( 'models/' )
        .load( 'can-cam.glb', function ( gltf ) {

            anim = gltf.animations;
            cams = gltf.cameras;
            camera = cams[0]
            mixer = new THREE.AnimationMixer( gltf )
            action = mixer.clipAction( anim[0], camera );
            action.play()
            model = gltf.scene;
            console.log(anim)
            console.log(camera)
            console.log(mixer)
            document.addEventListener( 'scroll', onScroll );
            window.addEventListener( 'resize', onWindowResize );
            document.addEventListener( 'pointer', onPoint );
            window.addEventListener('pointermove', onPointerMove);
            scene.add( model );
            JSON.stringify(scene)
            animate();


        } );

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;
    container.appendChild( renderer.domElement );

    const environment = new RoomEnvironment();
    const pmremGenerator = new THREE.PMREMGenerator( renderer );

    scene.background = new THREE.Color( 0xbbbbbb );
    scene.environment = pmremGenerator.fromScene( environment ).texture;
    // controls = new OrbitControls( camera, renderer.domElement );
    // controls.enableDamping = true;
    // controls.minDistance = 1;
    // controls.maxDistance = 10;
    // controls.target.set( 0, 0.35, 0 );
    // controls.update();

}
function handleScroll(event) {
const scrollDirection = Math.sign(event.deltaY); // -1 for scroll up, 1 for scroll down

// Adjust the current frame of the animation based on scroll direction
const currentFrame = action.time;
const frameIncrement = 0.01; // Adjust this value as needed
action.time = currentFrame + frameIncrement * scrollDirection;

// Render the updated frame
requestAnimationFrame(render);
}
function onPointerMove( e ) {
    pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
    pointer.y = (e.clientY / window.innerHeight) * 2 + 1;
}
function onPoint () {

}
function wait(ms: number | undefined) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function onScroll() {
    // play a single frame of the animation on scroll
    // get scroll percentage and normalize it
    let scroll = window.scrollY / (document.body.scrollHeight - window.innerHeight)
    // console.log(scroll)

    let results = mixer.clipAction( anim[0] ).play() 
    console.log(results)

    
}


function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

//

function animate() {

    requestAnimationFrame( animate );

    const delta = Clock.getDelta();

    mixer.update( delta );

    // controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

    render();

}

function render() {

    // raycaster.setFromCamera( pointer, camera );

    // const intersects = raycaster.intersectObjects( scene.children )

    // for ( let i = 0; i < intersects.length; i ++ ) {
    //     focus = intersects[i].point
    // }
    renderer.render( scene, camera );

}
</script>
<style>
    body {
        height: 400vh;
    }
</style>